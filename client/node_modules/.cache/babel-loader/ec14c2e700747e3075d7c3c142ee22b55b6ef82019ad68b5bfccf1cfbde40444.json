{"ast":null,"code":"import { getClientIdCache } from \"../../cache/auth\";\nimport { BITACORA_ROUTE } from \"../index\";\nexport const createEntry = async body => {\n  try {\n    const token = getClientIdCache();\n    if (token === null) {\n      return null;\n    }\n\n    // serialize\n    // deserialize\n    const res = await fetch(`${BITACORA_ROUTE}/new`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"Authorization\": token\n      },\n      body: JSON.stringify(body)\n    });\n    const resData = await res.json();\n  } catch (error) {\n    console.error(error);\n  }\n};\nexport const getEntries = async date => {\n  try {\n    const token = getClientIdCache();\n    if (token === null) {\n      return null;\n    }\n\n    // serialize\n    // deserialize\n    const res = await fetch(`${BITACORA_ROUTE}/${date}`, {\n      method: \"GET\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"Authorization\": token\n      }\n    });\n    const resData = await res.json();\n    return resData.data;\n  } catch (error) {\n    console.error(error);\n    return null;\n  }\n};\nexport const getEntry = async id => {\n  try {\n    // token is clientId\n    const token = getClientIdCache();\n    if (token === null) {\n      return null;\n    }\n\n    // serialize\n    // deserialize\n    const res = await fetch(`${BITACORA_ROUTE}/${id}/`, {\n      method: \"GET\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"Authorization\": token\n      }\n    });\n    const resData = await res.json();\n    return resData.data;\n  } catch (error) {\n    console.error(error);\n    return null;\n  }\n};\nexport const editEntries = async (id, date) => {\n  try {\n    const token = getClientIdCache();\n    if (token === null) {\n      return null;\n    }\n\n    // serialize\n    // deserialize\n    const res = await fetch(`${BITACORA_ROUTE}/${id}/${date}`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"Authorization\": token\n      }\n    });\n    const resData = await res.json();\n    return resData.data;\n  } catch (error) {\n    console.error(error);\n    return null;\n  }\n};","map":{"version":3,"names":["getClientIdCache","BITACORA_ROUTE","createEntry","body","token","res","fetch","method","headers","JSON","stringify","resData","json","error","console","getEntries","date","data","getEntry","id","editEntries"],"sources":["C:/Users/danie/Documents/natgas/client/src/routes/bitacora/bitacora.routes.ts"],"sourcesContent":["import { getClientIdCache } from \"../../cache/auth\";\r\nimport { BITACORA_ROUTE } from \"../index\";\r\n\r\ninterface ICreateEntry {\r\n    aDate: Date;\r\n    title: string;\r\n    content: string;\r\n}\r\n\r\nexport const createEntry = async (body: ICreateEntry) => {\r\n    try {\r\n\r\n        const token = getClientIdCache();\r\n\r\n        if (token === null) {\r\n            return null;\r\n        }\r\n\r\n        // serialize\r\n        // deserialize\r\n        const res = await fetch(`${BITACORA_ROUTE}/new`, {\r\n            method: \"POST\",\r\n            headers: {\r\n                \"Content-Type\": \"application/json\",\r\n                \"Authorization\": token\r\n            },\r\n            body: JSON.stringify(body)\r\n        });\r\n\r\n        const resData = await res.json();\r\n\r\n    } catch (error) {\r\n        console.error(error);\r\n    }\r\n};\r\n\r\nexport interface IGetEntriesData {\r\n    aDate: string;\r\n    content: string;\r\n    title: string;\r\n}\r\n\r\nexport const getEntries = async (date: Date): Promise<IGetEntriesData[] | null> => {\r\n    try {\r\n\r\n        const token = getClientIdCache();\r\n\r\n        if (token === null) {\r\n            return null;\r\n        }\r\n\r\n        // serialize\r\n        // deserialize\r\n        const res = await fetch(`${BITACORA_ROUTE}/${date}`, {\r\n            method: \"GET\",\r\n            headers: {\r\n                \"Content-Type\": \"application/json\",\r\n                \"Authorization\": token\r\n            }\r\n        });\r\n\r\n        const resData = await res.json();\r\n\r\n        return resData.data;\r\n\r\n    } catch (error) {\r\n        console.error(error);\r\n        return null;\r\n    }\r\n};\r\n\r\nexport const getEntry = async (id: string): Promise<IGetEntriesData[] | null> => {\r\n    try {\r\n        // token is clientId\r\n        const token = getClientIdCache();\r\n\r\n        if (token === null) {\r\n            return null;\r\n        }\r\n\r\n        // serialize\r\n        // deserialize\r\n        const res = await fetch(`${BITACORA_ROUTE}/${id}/`, {\r\n            method: \"GET\",\r\n            headers: {\r\n                \"Content-Type\": \"application/json\",\r\n                \"Authorization\": token\r\n            }\r\n        });\r\n\r\n        const resData = await res.json();\r\n\r\n        return resData.data;\r\n\r\n    } catch (error) {\r\n        console.error(error);\r\n        return null;\r\n    }\r\n};\r\n\r\nexport interface IEditEntriesData {\r\n    aDate: string;\r\n    content: string;\r\n    title: string;\r\n}\r\n\r\nexport const editEntries = async (id:string, date: Date): Promise<IEditEntriesData[] | null> => {\r\n    try {\r\n\r\n        const token = getClientIdCache();\r\n\r\n        if (token === null) {\r\n            return null;\r\n        }\r\n\r\n        // serialize\r\n        // deserialize\r\n        const res = await fetch(`${BITACORA_ROUTE}/${id}/${date}`, {\r\n            method: \"POST\",\r\n            headers: {\r\n                \"Content-Type\": \"application/json\",\r\n                \"Authorization\": token\r\n            }\r\n        });\r\n\r\n        const resData = await res.json();\r\n\r\n        return resData.data;\r\n\r\n    } catch (error) {\r\n        console.error(error);\r\n        return null;\r\n    }\r\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}